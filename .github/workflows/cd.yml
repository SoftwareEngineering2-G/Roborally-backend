name: Backend CD Pipeline

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # Allow manual trigger

env:
  DEPLOY_PATH: /var/www/roborally/backend

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --configuration Release --no-restore

      - name: Run tests
        run: dotnet test --no-restore --verbosity normal

      - name: Publish
        run: dotnet publish src/Roborally.webapi/Roborally.webapi.csproj -c Release -o ./publish

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-artifacts
          path: |
            ./publish
            Dockerfile
            docker-compose.prod.yml
          retention-days: 1

  deploy:
    name: Deploy to VM
    needs: build-and-test
    runs-on: ubuntu-latest
    
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-artifacts

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          VM_HOST: ${{ secrets.VM_HOST }}
          VM_USERNAME: ${{ secrets.VM_USERNAME }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $VM_HOST >> ~/.ssh/known_hosts

      - name: Deploy to VM
        env:
          VM_HOST: ${{ secrets.VM_HOST }}
          VM_USERNAME: ${{ secrets.VM_USERNAME }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        run: |
          # Create deployment script
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "üöÄ Starting backend deployment..."
          
          # Create directory if it doesn't exist
          mkdir -p $DEPLOY_PATH
          cd $DEPLOY_PATH
          
          # Stop existing containers
          if [ -f docker-compose.prod.yml ]; then
            echo "üõë Stopping existing containers..."
            docker-compose -f docker-compose.prod.yml down || true
          fi
          
          # Backup database (optional)
          if docker ps -a | grep -q roborally-postgres; then
            echo "üíæ Creating database backup..."
            docker exec roborally-postgres pg_dump -U $POSTGRES_USER $POSTGRES_DB > backup_$(date +%Y%m%d_%H%M%S).sql || true
          fi
          
          # Remove old files
          rm -rf publish/
          
          echo "‚úÖ Deployment preparation complete"
          EOF
          
          chmod +x deploy.sh
          
          # Copy files to VM
          echo "üì¶ Copying files to VM..."
          scp -i ~/.ssh/deploy_key -r ./publish $VM_USERNAME@$VM_HOST:$DEPLOY_PATH/
          scp -i ~/.ssh/deploy_key Dockerfile $VM_USERNAME@$VM_HOST:$DEPLOY_PATH/
          scp -i ~/.ssh/deploy_key docker-compose.prod.yml $VM_USERNAME@$VM_HOST:$DEPLOY_PATH/
          scp -i ~/.ssh/deploy_key deploy.sh $VM_USERNAME@$VM_HOST:$DEPLOY_PATH/
          
          # Execute deployment
          echo "üöÄ Executing deployment on VM..."
          ssh -i ~/.ssh/deploy_key $VM_USERNAME@$VM_HOST "cd $DEPLOY_PATH && ./deploy.sh"
          
          # Start services with environment variables
          echo "üê≥ Starting Docker containers..."
          ssh -i ~/.ssh/deploy_key $VM_USERNAME@$VM_HOST << EOF
            cd $DEPLOY_PATH
            export POSTGRES_PASSWORD='$POSTGRES_PASSWORD'
            export POSTGRES_USER='$POSTGRES_USER'
            export POSTGRES_DB='$POSTGRES_DB'
            docker-compose -f docker-compose.prod.yml up -d --build
            
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 30
            
            # Check service status
            docker-compose -f docker-compose.prod.yml ps
            
            # Show logs
            docker-compose -f docker-compose.prod.yml logs --tail=50
          EOF
          
          echo "‚úÖ Deployment complete!"

      - name: Health Check
        env:
          VM_HOST: ${{ secrets.VM_HOST }}
        run: |
          echo "üè• Running health check..."
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f http://$VM_HOST:5000/health; then
              echo "‚úÖ Backend is healthy!"
              exit 0
            fi
            echo "‚è≥ Attempt $attempt/$max_attempts failed, retrying in 10s..."
            sleep 10
            ((attempt++))
          done
          
          echo "‚ùå Health check failed after $max_attempts attempts"
          exit 1

      - name: Notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
          else
            echo "‚ùå Deployment failed!"
          fi